/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-2020 Philippe Proulx <pproulx@efficios.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * The following code was generated by barectf v3.0.1
 * on 2022-03-30T14:54:48.262431.
 *
 * For more details, see <https://barectf.org/>.
 */

#include <stdint.h>
#include <string.h>
#include <assert.h>

#include "barectf.h"
#include "barectf-bitfield.h"

#define _ALIGN(_at_var, _align)						\
	do {								\
		(_at_var) = ((_at_var) + ((_align) - 1)) & -(_align);	\
	} while (0)

#ifdef __cplusplus
# define _TO_VOID_PTR(_value)		static_cast<void *>(_value)
# define _FROM_VOID_PTR(_type, _value)	static_cast<_type *>(_value)
#else
# define _TO_VOID_PTR(_value)		((void *) (_value))
# define _FROM_VOID_PTR(_type, _value)	((_type *) (_value))
#endif

#define _BITS_TO_BYTES(_x)	((_x) >> 3)
#define _BYTES_TO_BITS(_x)	((_x) << 3)

union _f2u {
	float f;
	uint32_t u;
};

union _d2u {
	double f;
	uint64_t u;
};

uint32_t barectf_packet_size(const void * const vctx)
{
	return _FROM_VOID_PTR(const struct barectf_ctx, vctx)->packet_size;
}

int barectf_packet_is_full(const void * const vctx)
{
	const struct barectf_ctx * const ctx = _FROM_VOID_PTR(const struct barectf_ctx, vctx);

	return ctx->at == ctx->packet_size;
}

int barectf_packet_is_empty(const void * const vctx)
{
	const struct barectf_ctx * const ctx = _FROM_VOID_PTR(const struct barectf_ctx, vctx);

	return ctx->at <= ctx->off_content;
}

uint32_t barectf_packet_events_discarded(const void * const vctx)
{
	return _FROM_VOID_PTR(const struct barectf_ctx, vctx)->events_discarded;
}

uint32_t barectf_discarded_event_records_count(const void * const vctx)
{
	return barectf_packet_events_discarded(vctx);
}

uint8_t *barectf_packet_buf(const void * const vctx)
{
	return _FROM_VOID_PTR(const struct barectf_ctx, vctx)->buf;
}

uint8_t *barectf_packet_buf_addr(const void * const vctx)
{
	return barectf_packet_buf(vctx);
}

uint32_t barectf_packet_buf_size(const void * const vctx)
{
	const struct barectf_ctx * const ctx = _FROM_VOID_PTR(const struct barectf_ctx, vctx);

	return _BITS_TO_BYTES(ctx->packet_size);
}

void barectf_packet_set_buf(void * const vctx, uint8_t * const buf,
		const uint32_t buf_size)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	ctx->buf = buf;

	if (ctx->at == ctx->packet_size) {
		/* Keep full packet state */
		ctx->at = _BYTES_TO_BITS(buf_size);
	}

	ctx->packet_size = _BYTES_TO_BITS(buf_size);
}

int barectf_packet_is_open(const void * const vctx)
{
	return _FROM_VOID_PTR(const struct barectf_ctx, vctx)->packet_is_open;
}

int barectf_is_in_tracing_section(const void * const vctx)
{
	return _FROM_VOID_PTR(const struct barectf_ctx, vctx)->in_tracing_section;
}

volatile const int *barectf_is_in_tracing_section_ptr(const void * const vctx)
{
	return &_FROM_VOID_PTR(const struct barectf_ctx, vctx)->in_tracing_section;
}

int barectf_is_tracing_enabled(const void * const vctx)
{
	return _FROM_VOID_PTR(const struct barectf_ctx, vctx)->is_tracing_enabled;
}

void barectf_enable_tracing(void * const vctx, const int enable)
{
	_FROM_VOID_PTR(struct barectf_ctx, vctx)->is_tracing_enabled = enable;
}

static
void _write_c_str(struct barectf_ctx * const ctx, const char * const src)
{
	const uint32_t sz = strlen(src) + 1;

	memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], src, sz);
	ctx->at += _BYTES_TO_BITS(sz);
}

static
int _reserve_er_space(void * const vctx, const uint32_t er_size)
{
	int ret;
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Event _cannot_ fit? */
	if (er_size > (ctx->packet_size - ctx->off_content)) {
		goto no_space;
	}

	/* Packet is full? */
	if (barectf_packet_is_full(ctx)) {
		/* Yes: is the back end full? */
		if (ctx->cbs.is_backend_full(ctx->data)) {
			/* Yes: discard event record */
			goto no_space;
		}

		/* Back-end is _not_ full: open new packet */
		ctx->use_cur_last_event_ts = 1;
		ctx->cbs.open_packet(ctx->data);
		ctx->use_cur_last_event_ts = 0;
	}

	/* Event fits the current packet? */
	if (er_size > (ctx->packet_size - ctx->at)) {
		/* No: close packet now */
		ctx->use_cur_last_event_ts = 1;
		ctx->cbs.close_packet(ctx->data);
		ctx->use_cur_last_event_ts = 0;

		/* Is the back end full? */
		if (ctx->cbs.is_backend_full(ctx->data)) {
			/* Yes: discard event record */
			goto no_space;
		}

		/* Back-end is _not_ full: open new packet */
		ctx->use_cur_last_event_ts = 1;
		ctx->cbs.open_packet(ctx->data);
		ctx->use_cur_last_event_ts = 0;
		assert(er_size <= (ctx->packet_size - ctx->at));
	}

	ret = 1;
	goto end;

no_space:
	ctx->events_discarded++;
	ret = 0;

end:
	return ret;
}

static
void _commit_er(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Is the packet full? */
	if (barectf_packet_is_full(ctx)) {
		/* Yes: close it now */
		ctx->cbs.close_packet(ctx->data);
	}
}

/* Initialize context */
void barectf_init(void *vctx,
	uint8_t * const buf, const uint32_t buf_size,
	const struct barectf_platform_callbacks cbs, void * const data)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	ctx->cbs = cbs;
	ctx->data = data;
	ctx->buf = buf;
	ctx->packet_size = _BYTES_TO_BITS(buf_size);
	ctx->at = 0;
	ctx->events_discarded = 0;
	ctx->packet_is_open = 0;
	ctx->in_tracing_section = 0;
	ctx->is_tracing_enabled = 1;
	ctx->use_cur_last_event_ts = 0;
}

/* Open packet for data stream type `default` */
void barectf_default_open_packet(
	struct barectf_default_ctx * const sctx)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	const uint64_t ts = ctx->use_cur_last_event_ts ?
		sctx->cur_last_event_ts :
		ctx->cbs.default_clock_get_value(ctx->data);
	const int saved_in_tracing_section = ctx->in_tracing_section;

	/*
	 * This function is either called by a tracing function, or
	 * directly by the platform.
	 *
	 * If it's called by a tracing function, then
	 * `ctx->in_tracing_section` is 1, so it's safe to open
	 * the packet here (alter the packet), even if tracing was
	 * disabled in the meantime because we're already in a tracing
	 * section (which finishes at the end of the tracing function
	 * call).
	 *
	 * If it's called directly by the platform, then if tracing is
	 * disabled, we don't want to alter the packet, and return
	 * immediately.
	 */
	if (!ctx->is_tracing_enabled && !saved_in_tracing_section) {
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Do not open a packet that is already open */
	if (ctx->packet_is_open) {
		ctx->in_tracing_section = saved_in_tracing_section;
		goto end;
	}

	ctx->at = 0;

	/* Write packet header structure */
	{
		/* Align for packet header structure */
		_ALIGN(ctx->at, 8);

		/* Align for `magic` field */
		_ALIGN(ctx->at, 8);

		/* Write magic number field */
		{
			const uint32_t tmp_val = (uint32_t) 0xc1fc1fc1UL;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `stream_id` field */
		_ALIGN(ctx->at, 8);

		/* Write data stream type ID field */
		{
			const uint64_t tmp_val = (uint64_t) 0;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}

	/* Write packet context structure */
	{
		/* Align for packet context structure */
		_ALIGN(ctx->at, 8);

		/* Align for `packet_size` field */
		_ALIGN(ctx->at, 8);

		/* Write packet total size field */
		{
			const uint64_t tmp_val = (uint64_t) ctx->packet_size;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `content_size` field */
		_ALIGN(ctx->at, 8);

		/* Do not write `content_size` field; save its offset */
		sctx->off_pc_content_size = ctx->at;
		ctx->at += 64;

		/* Align for `timestamp_begin` field */
		_ALIGN(ctx->at, 8);

		/* Write beginning timestamp field */
		{
			const uint64_t tmp_val = (uint64_t) ts;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `timestamp_end` field */
		_ALIGN(ctx->at, 8);

		/* Do not write `timestamp_end` field; save its offset */
		sctx->off_pc_timestamp_end = ctx->at;
		ctx->at += 64;

		/* Align for `events_discarded` field */
		_ALIGN(ctx->at, 8);

		/* Do not write `events_discarded` field; save its offset */
		sctx->off_pc_events_discarded = ctx->at;
		ctx->at += 64;
	}

	/* Save content beginning's offset */
	ctx->off_content = ctx->at;

	/* Mark current packet as open */
	ctx->packet_is_open = 1;

	/* Not tracing anymore */
	ctx->in_tracing_section = saved_in_tracing_section;

end:
	return;
}

/* Close packet for data stream type `default` */
void barectf_default_close_packet(struct barectf_default_ctx * const sctx)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	const uint64_t ts = ctx->use_cur_last_event_ts ?
		sctx->cur_last_event_ts :
		ctx->cbs.default_clock_get_value(ctx->data);
	const int saved_in_tracing_section = ctx->in_tracing_section;

	/*
	 * This function is either called by a tracing function, or
	 * directly by the platform.
	 *
	 * If it's called by a tracing function, then
	 * `ctx->in_tracing_section` is 1, so it's safe to close
	 * the packet here (alter the packet), even if tracing was
	 * disabled in the meantime, because we're already in a tracing
	 * section (which finishes at the end of the tracing function
	 * call).
	 *
	 * If it's called directly by the platform, then if tracing is
	 * disabled, we don't want to alter the packet, and return
	 * immediately.
	 */
	if (!ctx->is_tracing_enabled && !saved_in_tracing_section) {
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Do not close a packet that is not open */
	if (!ctx->packet_is_open) {
		ctx->in_tracing_section = saved_in_tracing_section;
		goto end;
	}

	/* Save content size */
	ctx->content_size = ctx->at;

	/* Go back to `timestamp_end` field offset */
	ctx->at = sctx->off_pc_timestamp_end;

	/* Write `timestamp_end` field */
	{
		const uint64_t tmp_val = (uint64_t) ts;

		memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
		ctx->at += 64;
	}

	/* Go back to `content_size` field offset */
	ctx->at = sctx->off_pc_content_size;

	/* Write `content_size` field */
	{
		const uint64_t tmp_val = (uint64_t) ctx->content_size;

		memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
		ctx->at += 64;
	}

	/* Go back to `events_discarded` field offset */
	ctx->at = sctx->off_pc_events_discarded;

	/* Write `events_discarded` field */
	{
		const uint64_t tmp_val = (uint64_t) ctx->events_discarded;

		memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
		ctx->at += 64;
	}

	/* Go back to end of packet */
	ctx->at = ctx->packet_size;

	/* Mark packet as closed */
	ctx->packet_is_open = 0;

	/* Not tracing anymore */
	ctx->in_tracing_section = saved_in_tracing_section;

end:
	return;
}

static void _serialize_er_header_default(void * const vctx,
	const uint32_t ert_id)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	struct barectf_default_ctx * const sctx = _FROM_VOID_PTR(struct barectf_default_ctx, vctx);
	const uint64_t ts = sctx->cur_last_event_ts;

	/* Write header structure */
	{
		/* Align for header structure */
		_ALIGN(ctx->at, 8);

		/* Align for `id` field */
		_ALIGN(ctx->at, 8);

		/* Write event record type ID field */
		{
			const uint64_t tmp_val = (uint64_t) ert_id;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `timestamp` field */
		_ALIGN(ctx->at, 8);

		/* Write timestamp field */
		{
			const uint64_t tmp_val = (uint64_t) ts;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_hip_activity(void * const vctx,
	const uint32_t p_device_id,
	const uint64_t p_queue_id,
	const char * const p_name,
	const uint64_t p_correlation_id,
	const uint32_t p_pid,
	const uint64_t p_end)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 0);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `device_id` field */
		_ALIGN(ctx->at, 32);

		/* Write `device_id` field */
		{
			const uint32_t tmp_val = (uint32_t) p_device_id;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `queue_id` field */
		_ALIGN(ctx->at, 64);

		/* Write `queue_id` field */
		{
			const uint64_t tmp_val = (uint64_t) p_queue_id;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 8);

		/* Write `name` field */
		_write_c_str(ctx, p_name);

		/* Align for `correlation_id` field */
		_ALIGN(ctx->at, 64);

		/* Write `correlation_id` field */
		{
			const uint64_t tmp_val = (uint64_t) p_correlation_id;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `pid` field */
		_ALIGN(ctx->at, 32);

		/* Write `pid` field */
		{
			const uint32_t tmp_val = (uint32_t) p_pid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `end` field */
		_ALIGN(ctx->at, 64);

		/* Write `end` field */
		{
			const uint64_t tmp_val = (uint64_t) p_end;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_hip_api(void * const vctx,
	const uint32_t p_cid,
	const uint32_t p_pid,
	const uint32_t p_tid,
	const char * const p_args,
	const uint64_t p_end)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 1);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `cid` field */
		_ALIGN(ctx->at, 32);

		/* Write `cid` field */
		{
			const uint32_t tmp_val = (uint32_t) p_cid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `pid` field */
		_ALIGN(ctx->at, 32);

		/* Write `pid` field */
		{
			const uint32_t tmp_val = (uint32_t) p_pid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `tid` field */
		_ALIGN(ctx->at, 32);

		/* Write `tid` field */
		{
			const uint32_t tmp_val = (uint32_t) p_tid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `args` field */
		_ALIGN(ctx->at, 8);

		/* Write `args` field */
		_write_c_str(ctx, p_args);

		/* Align for `end` field */
		_ALIGN(ctx->at, 64);

		/* Write `end` field */
		{
			const uint64_t tmp_val = (uint64_t) p_end;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_hip_function_name(void * const vctx,
	const uint64_t p_correlation_id,
	const char * const p_name)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 2);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `correlation_id` field */
		_ALIGN(ctx->at, 64);

		/* Write `correlation_id` field */
		{
			const uint64_t tmp_val = (uint64_t) p_correlation_id;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 8);

		/* Write `name` field */
		_write_c_str(ctx, p_name);
	}
}

static void _serialize_er_default_hsa_activity(void * const vctx,
	const uint32_t p_pid,
	const uint64_t p_index,
	const uint64_t p_end)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 3);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `pid` field */
		_ALIGN(ctx->at, 32);

		/* Write `pid` field */
		{
			const uint32_t tmp_val = (uint32_t) p_pid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `index` field */
		_ALIGN(ctx->at, 64);

		/* Write `index` field */
		{
			const uint64_t tmp_val = (uint64_t) p_index;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `end` field */
		_ALIGN(ctx->at, 64);

		/* Write `end` field */
		{
			const uint64_t tmp_val = (uint64_t) p_end;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_hsa_api(void * const vctx,
	const uint32_t p_cid,
	const uint32_t p_pid,
	const uint32_t p_tid,
	const char * const p_args,
	const char * const p_retval,
	const uint64_t p_end)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 4);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `cid` field */
		_ALIGN(ctx->at, 32);

		/* Write `cid` field */
		{
			const uint32_t tmp_val = (uint32_t) p_cid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `pid` field */
		_ALIGN(ctx->at, 32);

		/* Write `pid` field */
		{
			const uint32_t tmp_val = (uint32_t) p_pid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `tid` field */
		_ALIGN(ctx->at, 32);

		/* Write `tid` field */
		{
			const uint32_t tmp_val = (uint32_t) p_tid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `args` field */
		_ALIGN(ctx->at, 8);

		/* Write `args` field */
		_write_c_str(ctx, p_args);

		/* Align for `retval` field */
		_ALIGN(ctx->at, 8);

		/* Write `retval` field */
		_write_c_str(ctx, p_retval);

		/* Align for `end` field */
		_ALIGN(ctx->at, 64);

		/* Write `end` field */
		{
			const uint64_t tmp_val = (uint64_t) p_end;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_hsa_function_name(void * const vctx,
	const uint64_t p_correlation_id,
	const char * const p_name)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 5);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `correlation_id` field */
		_ALIGN(ctx->at, 64);

		/* Write `correlation_id` field */
		{
			const uint64_t tmp_val = (uint64_t) p_correlation_id;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 8);

		/* Write `name` field */
		_write_c_str(ctx, p_name);
	}
}

static void _serialize_er_default_kernel_event(void * const vctx,
	const uint32_t p_dispatch,
	const uint32_t p_gpu_id,
	const uint32_t p_queue_id,
	const uint64_t p_queue_index,
	const uint32_t p_pid,
	const uint32_t p_tid,
	const uint32_t p_grd,
	const uint32_t p_wgr,
	const uint32_t p_lds,
	const uint32_t p_scr,
	const uint32_t p_vgpr,
	const uint32_t p_sgpr,
	const uint32_t p_fbar,
	const uint64_t p_sig,
	const uint64_t p_obj,
	const char * const p_kernel_name,
	const uint64_t p_dispatch_time,
	const uint64_t p_complete_time,
	const uint64_t p_end)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 6);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `dispatch` field */
		_ALIGN(ctx->at, 32);

		/* Write `dispatch` field */
		{
			const uint32_t tmp_val = (uint32_t) p_dispatch;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `gpu_id` field */
		_ALIGN(ctx->at, 32);

		/* Write `gpu_id` field */
		{
			const uint32_t tmp_val = (uint32_t) p_gpu_id;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `queue_id` field */
		_ALIGN(ctx->at, 32);

		/* Write `queue_id` field */
		{
			const uint32_t tmp_val = (uint32_t) p_queue_id;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `queue_index` field */
		_ALIGN(ctx->at, 64);

		/* Write `queue_index` field */
		{
			const uint64_t tmp_val = (uint64_t) p_queue_index;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `pid` field */
		_ALIGN(ctx->at, 32);

		/* Write `pid` field */
		{
			const uint32_t tmp_val = (uint32_t) p_pid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `tid` field */
		_ALIGN(ctx->at, 32);

		/* Write `tid` field */
		{
			const uint32_t tmp_val = (uint32_t) p_tid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `grd` field */
		_ALIGN(ctx->at, 32);

		/* Write `grd` field */
		{
			const uint32_t tmp_val = (uint32_t) p_grd;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `wgr` field */
		_ALIGN(ctx->at, 32);

		/* Write `wgr` field */
		{
			const uint32_t tmp_val = (uint32_t) p_wgr;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `lds` field */
		_ALIGN(ctx->at, 32);

		/* Write `lds` field */
		{
			const uint32_t tmp_val = (uint32_t) p_lds;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `scr` field */
		_ALIGN(ctx->at, 32);

		/* Write `scr` field */
		{
			const uint32_t tmp_val = (uint32_t) p_scr;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `vgpr` field */
		_ALIGN(ctx->at, 32);

		/* Write `vgpr` field */
		{
			const uint32_t tmp_val = (uint32_t) p_vgpr;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `sgpr` field */
		_ALIGN(ctx->at, 32);

		/* Write `sgpr` field */
		{
			const uint32_t tmp_val = (uint32_t) p_sgpr;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `fbar` field */
		_ALIGN(ctx->at, 32);

		/* Write `fbar` field */
		{
			const uint32_t tmp_val = (uint32_t) p_fbar;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `sig` field */
		_ALIGN(ctx->at, 8);

		/* Write `sig` field */
		{
			const uint64_t tmp_val = (uint64_t) p_sig;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `obj` field */
		_ALIGN(ctx->at, 8);

		/* Write `obj` field */
		{
			const uint64_t tmp_val = (uint64_t) p_obj;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `kernel_name` field */
		_ALIGN(ctx->at, 8);

		/* Write `kernel_name` field */
		_write_c_str(ctx, p_kernel_name);

		/* Align for `dispatch_time` field */
		_ALIGN(ctx->at, 64);

		/* Write `dispatch_time` field */
		{
			const uint64_t tmp_val = (uint64_t) p_dispatch_time;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `complete_time` field */
		_ALIGN(ctx->at, 64);

		/* Write `complete_time` field */
		{
			const uint64_t tmp_val = (uint64_t) p_complete_time;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `end` field */
		_ALIGN(ctx->at, 64);

		/* Write `end` field */
		{
			const uint64_t tmp_val = (uint64_t) p_end;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_metric_double(void * const vctx,
	const uint32_t p_id,
	const uint32_t p_dispatch,
	const uint32_t p_gpu_id,
	const double p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 7);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `id` field */
		_ALIGN(ctx->at, 32);

		/* Write `id` field */
		{
			const uint32_t tmp_val = (uint32_t) p_id;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `dispatch` field */
		_ALIGN(ctx->at, 32);

		/* Write `dispatch` field */
		{
			const uint32_t tmp_val = (uint32_t) p_dispatch;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `gpu_id` field */
		_ALIGN(ctx->at, 32);

		/* Write `gpu_id` field */
		{
			const uint32_t tmp_val = (uint32_t) p_gpu_id;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 64);

		/* Write `value` field */
		{
			union _d2u d2u;

			d2u.f = p_value;
			{
				const uint64_t tmp_val = (uint64_t) d2u.u;

				memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
				ctx->at += 64;
			}
		}
	}
}

static void _serialize_er_default_metric_name(void * const vctx,
	const uint32_t p_id,
	const char * const p_name)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 8);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 32);

		/* Align for `id` field */
		_ALIGN(ctx->at, 32);

		/* Write `id` field */
		{
			const uint32_t tmp_val = (uint32_t) p_id;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `name` field */
		_ALIGN(ctx->at, 8);

		/* Write `name` field */
		_write_c_str(ctx, p_name);
	}
}

static void _serialize_er_default_metric_name_end(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 9);

	/* Write payload structure */
	{
	}
}

static void _serialize_er_default_metric_uint64(void * const vctx,
	const uint32_t p_id,
	const uint32_t p_dispatch,
	const uint32_t p_gpu_id,
	const uint64_t p_value)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 10);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `id` field */
		_ALIGN(ctx->at, 32);

		/* Write `id` field */
		{
			const uint32_t tmp_val = (uint32_t) p_id;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `dispatch` field */
		_ALIGN(ctx->at, 32);

		/* Write `dispatch` field */
		{
			const uint32_t tmp_val = (uint32_t) p_dispatch;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `gpu_id` field */
		_ALIGN(ctx->at, 32);

		/* Write `gpu_id` field */
		{
			const uint32_t tmp_val = (uint32_t) p_gpu_id;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `value` field */
		_ALIGN(ctx->at, 64);

		/* Write `value` field */
		{
			const uint64_t tmp_val = (uint64_t) p_value;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}
	}
}

static void _serialize_er_default_roctx(void * const vctx,
	const uint32_t p_cid,
	const uint32_t p_pid,
	const uint32_t p_tid,
	const uint64_t p_rid,
	const char * const p_message)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);

	/* Serialize header */
	_serialize_er_header_default(ctx, 11);

	/* Write payload structure */
	{
		/* Align for payload structure */
		_ALIGN(ctx->at, 64);

		/* Align for `cid` field */
		_ALIGN(ctx->at, 32);

		/* Write `cid` field */
		{
			const uint32_t tmp_val = (uint32_t) p_cid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `pid` field */
		_ALIGN(ctx->at, 32);

		/* Write `pid` field */
		{
			const uint32_t tmp_val = (uint32_t) p_pid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `tid` field */
		_ALIGN(ctx->at, 32);

		/* Write `tid` field */
		{
			const uint32_t tmp_val = (uint32_t) p_tid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 32;
		}

		/* Align for `rid` field */
		_ALIGN(ctx->at, 64);

		/* Write `rid` field */
		{
			const uint64_t tmp_val = (uint64_t) p_rid;

			memcpy(&ctx->buf[_BITS_TO_BYTES(ctx->at)], &tmp_val, sizeof(tmp_val));
			ctx->at += 64;
		}

		/* Align for `message` field */
		_ALIGN(ctx->at, 8);

		/* Write `message` field */
		_write_c_str(ctx, p_message);
	}
}

static uint32_t _er_size_default_hip_activity(void * const vctx,
	const char * const p_name)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `device_id` field */
		_ALIGN(at, 32);

		/* Add `device_id` bit array field's size */
		at += 32;

		/* Align for `queue_id` field */
		_ALIGN(at, 64);

		/* Add `queue_id` bit array field's size */
		at += 64;

		/* Align for `name` field */
		_ALIGN(at, 8);

		/* Add `name` string field's size */
		at += _BYTES_TO_BITS(strlen(p_name) + 1);

		/* Align for `correlation_id` field */
		_ALIGN(at, 64);

		/* Add `correlation_id` bit array field's size */
		at += 64;

		/* Align for `pid` field */
		_ALIGN(at, 32);

		/* Add `pid` bit array field's size */
		at += 32;

		/* Align for `end` field */
		_ALIGN(at, 64);

		/* Add `end` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_hip_api(void * const vctx,
	const char * const p_args)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `cid` field */
		_ALIGN(at, 32);

		/* Add `cid` bit array field's size */
		at += 32;

		/* Align for `pid` field */
		_ALIGN(at, 32);

		/* Add `pid` bit array field's size */
		at += 32;

		/* Align for `tid` field */
		_ALIGN(at, 32);

		/* Add `tid` bit array field's size */
		at += 32;

		/* Align for `args` field */
		_ALIGN(at, 8);

		/* Add `args` string field's size */
		at += _BYTES_TO_BITS(strlen(p_args) + 1);

		/* Align for `end` field */
		_ALIGN(at, 64);

		/* Add `end` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_hip_function_name(void * const vctx,
	const char * const p_name)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `correlation_id` field */
		_ALIGN(at, 64);

		/* Add `correlation_id` bit array field's size */
		at += 64;

		/* Align for `name` field */
		_ALIGN(at, 8);

		/* Add `name` string field's size */
		at += _BYTES_TO_BITS(strlen(p_name) + 1);
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_hsa_activity(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `pid` field */
		_ALIGN(at, 32);

		/* Add `pid` bit array field's size */
		at += 32;

		/* Align for `index` field */
		_ALIGN(at, 64);

		/* Add `index` bit array field's size */
		at += 64;

		/* Align for `end` field */
		_ALIGN(at, 64);

		/* Add `end` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_hsa_api(void * const vctx,
	const char * const p_args,
	const char * const p_retval)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `cid` field */
		_ALIGN(at, 32);

		/* Add `cid` bit array field's size */
		at += 32;

		/* Align for `pid` field */
		_ALIGN(at, 32);

		/* Add `pid` bit array field's size */
		at += 32;

		/* Align for `tid` field */
		_ALIGN(at, 32);

		/* Add `tid` bit array field's size */
		at += 32;

		/* Align for `args` field */
		_ALIGN(at, 8);

		/* Add `args` string field's size */
		at += _BYTES_TO_BITS(strlen(p_args) + 1);

		/* Align for `retval` field */
		_ALIGN(at, 8);

		/* Add `retval` string field's size */
		at += _BYTES_TO_BITS(strlen(p_retval) + 1);

		/* Align for `end` field */
		_ALIGN(at, 64);

		/* Add `end` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_hsa_function_name(void * const vctx,
	const char * const p_name)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `correlation_id` field */
		_ALIGN(at, 64);

		/* Add `correlation_id` bit array field's size */
		at += 64;

		/* Align for `name` field */
		_ALIGN(at, 8);

		/* Add `name` string field's size */
		at += _BYTES_TO_BITS(strlen(p_name) + 1);
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_kernel_event(void * const vctx,
	const char * const p_kernel_name)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `dispatch` field */
		_ALIGN(at, 32);

		/* Add `dispatch` bit array field's size */
		at += 32;

		/* Align for `gpu_id` field */
		_ALIGN(at, 32);

		/* Add `gpu_id` bit array field's size */
		at += 32;

		/* Align for `queue_id` field */
		_ALIGN(at, 32);

		/* Add `queue_id` bit array field's size */
		at += 32;

		/* Align for `queue_index` field */
		_ALIGN(at, 64);

		/* Add `queue_index` bit array field's size */
		at += 64;

		/* Align for `pid` field */
		_ALIGN(at, 32);

		/* Add `pid` bit array field's size */
		at += 32;

		/* Align for `tid` field */
		_ALIGN(at, 32);

		/* Add `tid` bit array field's size */
		at += 32;

		/* Align for `grd` field */
		_ALIGN(at, 32);

		/* Add `grd` bit array field's size */
		at += 32;

		/* Align for `wgr` field */
		_ALIGN(at, 32);

		/* Add `wgr` bit array field's size */
		at += 32;

		/* Align for `lds` field */
		_ALIGN(at, 32);

		/* Add `lds` bit array field's size */
		at += 32;

		/* Align for `scr` field */
		_ALIGN(at, 32);

		/* Add `scr` bit array field's size */
		at += 32;

		/* Align for `vgpr` field */
		_ALIGN(at, 32);

		/* Add `vgpr` bit array field's size */
		at += 32;

		/* Align for `sgpr` field */
		_ALIGN(at, 32);

		/* Add `sgpr` bit array field's size */
		at += 32;

		/* Align for `fbar` field */
		_ALIGN(at, 32);

		/* Add `fbar` bit array field's size */
		at += 32;

		/* Align for `sig` field */
		_ALIGN(at, 8);

		/* Add `sig` bit array field's size */
		at += 64;

		/* Align for `obj` field */
		_ALIGN(at, 8);

		/* Add `obj` bit array field's size */
		at += 64;

		/* Align for `kernel_name` field */
		_ALIGN(at, 8);

		/* Add `kernel_name` string field's size */
		at += _BYTES_TO_BITS(strlen(p_kernel_name) + 1);

		/* Align for `dispatch_time` field */
		_ALIGN(at, 64);

		/* Add `dispatch_time` bit array field's size */
		at += 64;

		/* Align for `complete_time` field */
		_ALIGN(at, 64);

		/* Add `complete_time` bit array field's size */
		at += 64;

		/* Align for `end` field */
		_ALIGN(at, 64);

		/* Add `end` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_metric_double(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `id` field */
		_ALIGN(at, 32);

		/* Add `id` bit array field's size */
		at += 32;

		/* Align for `dispatch` field */
		_ALIGN(at, 32);

		/* Add `dispatch` bit array field's size */
		at += 32;

		/* Align for `gpu_id` field */
		_ALIGN(at, 32);

		/* Add `gpu_id` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 64);

		/* Add `value` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_metric_name(void * const vctx,
	const char * const p_name)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 32);

		/* Align for `id` field */
		_ALIGN(at, 32);

		/* Add `id` bit array field's size */
		at += 32;

		/* Align for `name` field */
		_ALIGN(at, 8);

		/* Add `name` string field's size */
		at += _BYTES_TO_BITS(strlen(p_name) + 1);
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_metric_name_end(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_metric_uint64(void * const vctx)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `id` field */
		_ALIGN(at, 32);

		/* Add `id` bit array field's size */
		at += 32;

		/* Align for `dispatch` field */
		_ALIGN(at, 32);

		/* Add `dispatch` bit array field's size */
		at += 32;

		/* Align for `gpu_id` field */
		_ALIGN(at, 32);

		/* Add `gpu_id` bit array field's size */
		at += 32;

		/* Align for `value` field */
		_ALIGN(at, 64);

		/* Add `value` bit array field's size */
		at += 64;
	}

	return at - ctx->at;
}

static uint32_t _er_size_default_roctx(void * const vctx,
	const char * const p_message)
{
	struct barectf_ctx * const ctx = _FROM_VOID_PTR(struct barectf_ctx, vctx);
	uint32_t at = ctx->at;

	/* Add header structure size */
	{
		/* Align for header structure */
		_ALIGN(at, 8);

		/* Align for `id` field */
		_ALIGN(at, 8);

		/* Add `id` bit array field's size */
		at += 64;

		/* Align for `timestamp` field */
		_ALIGN(at, 8);

		/* Add `timestamp` bit array field's size */
		at += 64;
	}

	/* Add payload structure size */
	{
		/* Align for payload structure */
		_ALIGN(at, 64);

		/* Align for `cid` field */
		_ALIGN(at, 32);

		/* Add `cid` bit array field's size */
		at += 32;

		/* Align for `pid` field */
		_ALIGN(at, 32);

		/* Add `pid` bit array field's size */
		at += 32;

		/* Align for `tid` field */
		_ALIGN(at, 32);

		/* Add `tid` bit array field's size */
		at += 32;

		/* Align for `rid` field */
		_ALIGN(at, 64);

		/* Add `rid` bit array field's size */
		at += 64;

		/* Align for `message` field */
		_ALIGN(at, 8);

		/* Add `message` string field's size */
		at += _BYTES_TO_BITS(strlen(p_message) + 1);
	}

	return at - ctx->at;
}

/* Trace (data stream type `default`, event record type `hip_activity`) */
void barectf_default_trace_hip_activity(struct barectf_default_ctx * const sctx,
	const uint32_t p_device_id,
	const uint64_t p_queue_id,
	const char * const p_name,
	const uint64_t p_correlation_id,
	const uint32_t p_pid,
	const uint64_t p_end)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_hip_activity(_TO_VOID_PTR(ctx), p_name);

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_hip_activity(_TO_VOID_PTR(ctx), p_device_id, p_queue_id, p_name, p_correlation_id, p_pid, p_end);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `hip_api`) */
void barectf_default_trace_hip_api(struct barectf_default_ctx * const sctx,
	const uint32_t p_cid,
	const uint32_t p_pid,
	const uint32_t p_tid,
	const char * const p_args,
	const uint64_t p_end)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_hip_api(_TO_VOID_PTR(ctx), p_args);

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_hip_api(_TO_VOID_PTR(ctx), p_cid, p_pid, p_tid, p_args, p_end);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `hip_function_name`) */
void barectf_default_trace_hip_function_name(struct barectf_default_ctx * const sctx,
	const uint64_t p_correlation_id,
	const char * const p_name)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_hip_function_name(_TO_VOID_PTR(ctx), p_name);

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_hip_function_name(_TO_VOID_PTR(ctx), p_correlation_id, p_name);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `hsa_activity`) */
void barectf_default_trace_hsa_activity(struct barectf_default_ctx * const sctx,
	const uint32_t p_pid,
	const uint64_t p_index,
	const uint64_t p_end)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_hsa_activity(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_hsa_activity(_TO_VOID_PTR(ctx), p_pid, p_index, p_end);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `hsa_api`) */
void barectf_default_trace_hsa_api(struct barectf_default_ctx * const sctx,
	const uint32_t p_cid,
	const uint32_t p_pid,
	const uint32_t p_tid,
	const char * const p_args,
	const char * const p_retval,
	const uint64_t p_end)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_hsa_api(_TO_VOID_PTR(ctx), p_args, p_retval);

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_hsa_api(_TO_VOID_PTR(ctx), p_cid, p_pid, p_tid, p_args, p_retval, p_end);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `hsa_function_name`) */
void barectf_default_trace_hsa_function_name(struct barectf_default_ctx * const sctx,
	const uint64_t p_correlation_id,
	const char * const p_name)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_hsa_function_name(_TO_VOID_PTR(ctx), p_name);

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_hsa_function_name(_TO_VOID_PTR(ctx), p_correlation_id, p_name);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `kernel_event`) */
void barectf_default_trace_kernel_event(struct barectf_default_ctx * const sctx,
	const uint32_t p_dispatch,
	const uint32_t p_gpu_id,
	const uint32_t p_queue_id,
	const uint64_t p_queue_index,
	const uint32_t p_pid,
	const uint32_t p_tid,
	const uint32_t p_grd,
	const uint32_t p_wgr,
	const uint32_t p_lds,
	const uint32_t p_scr,
	const uint32_t p_vgpr,
	const uint32_t p_sgpr,
	const uint32_t p_fbar,
	const uint64_t p_sig,
	const uint64_t p_obj,
	const char * const p_kernel_name,
	const uint64_t p_dispatch_time,
	const uint64_t p_complete_time,
	const uint64_t p_end)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_kernel_event(_TO_VOID_PTR(ctx), p_kernel_name);

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_kernel_event(_TO_VOID_PTR(ctx), p_dispatch, p_gpu_id, p_queue_id, p_queue_index, p_pid, p_tid, p_grd, p_wgr, p_lds, p_scr, p_vgpr, p_sgpr, p_fbar, p_sig, p_obj, p_kernel_name, p_dispatch_time, p_complete_time, p_end);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `metric_double`) */
void barectf_default_trace_metric_double(struct barectf_default_ctx * const sctx,
	const uint32_t p_id,
	const uint32_t p_dispatch,
	const uint32_t p_gpu_id,
	const double p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_metric_double(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_metric_double(_TO_VOID_PTR(ctx), p_id, p_dispatch, p_gpu_id, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `metric_name`) */
void barectf_default_trace_metric_name(struct barectf_default_ctx * const sctx,
	const uint32_t p_id,
	const char * const p_name)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_metric_name(_TO_VOID_PTR(ctx), p_name);

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_metric_name(_TO_VOID_PTR(ctx), p_id, p_name);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `metric_name_end`) */
void barectf_default_trace_metric_name_end(struct barectf_default_ctx * const sctx)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_metric_name_end(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_metric_name_end(_TO_VOID_PTR(ctx));

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `metric_uint64`) */
void barectf_default_trace_metric_uint64(struct barectf_default_ctx * const sctx,
	const uint32_t p_id,
	const uint32_t p_dispatch,
	const uint32_t p_gpu_id,
	const uint64_t p_value)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_metric_uint64(_TO_VOID_PTR(ctx));

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_metric_uint64(_TO_VOID_PTR(ctx), p_id, p_dispatch, p_gpu_id, p_value);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}

/* Trace (data stream type `default`, event record type `roctx`) */
void barectf_default_trace_roctx(struct barectf_default_ctx * const sctx,
	const uint32_t p_cid,
	const uint32_t p_pid,
	const uint32_t p_tid,
	const uint64_t p_rid,
	const char * const p_message)
{
	struct barectf_ctx * const ctx = &sctx->parent;
	uint32_t er_size;

	/* Save timestamp */
	sctx->cur_last_event_ts = ctx->cbs.default_clock_get_value(ctx->data);

	if (!ctx->is_tracing_enabled) {
		goto end;
	}

	/* We can alter the packet */
	ctx->in_tracing_section = 1;

	/* Compute event record size */
	er_size = _er_size_default_roctx(_TO_VOID_PTR(ctx), p_message);

	/* Is there enough space to serialize? */
	if (!_reserve_er_space(_TO_VOID_PTR(ctx), er_size)) {
		/* no: forget this */
		ctx->in_tracing_section = 0;
		goto end;
	}

	/* Serialize event record */
	_serialize_er_default_roctx(_TO_VOID_PTR(ctx), p_cid, p_pid, p_tid, p_rid, p_message);

	/* Commit event record */
	_commit_er(_TO_VOID_PTR(ctx));

	/* Not tracing anymore */
	ctx->in_tracing_section = 0;

end:
	return;
}
